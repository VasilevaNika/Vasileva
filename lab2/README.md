# Отчет по лабораторной работе №2
## Работа с коллекциями

## 1. Подход к реализации замеров

Для измерения производительности операций над коллекциями был реализован класс CollectionBenchmark, который выполняет следующие действия:

### Методология измерения
- Размер коллекции: 100,000 элементов
- Количество итераций: 5 измерений для каждой операции с последующим усреднением результатов
- Прогрев: перед каждым измерением выполняется 3 итерации для стабилизации JIT-компиляции
- Инструмент измерения: System.Diagnostics.Stopwatch для точного измерения времени выполнения
- Очистка памяти: между измерениями выполняется GC.Collect() для минимизации влияния сборщика мусора на результаты

### Тестируемые операции
Для каждой коллекции (List<T>, LinkedList<T>, Queue<T>, Stack<T>, ImmutableList<T>) измерялись следующие операции:
- Добавление элементов: в конец, в начало, в середину коллекции
- Удаление элементов: из начала, из конца, из середины коллекции
- Поиск элемента: по значению с использованием метода Contains()
- Получение по индексу: доступ к элементу по индексу (если применимо для коллекции)

### Автоматизированное тестирование
Для проверки корректности операций были написаны unit-тесты с использованием фреймворка xUnit. Тесты проверяют правильность выполнения всех операций для каждой коллекции и являются детерминированными и воспроизводимыми.

## 2. Результаты замеров

Результаты замеров выводятся в консоль после выполнения программы. Ниже представлена структура результатов:

| Коллекция | Операция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|----------|-------------------|----------|-----------|
| List<T> | Добавление в конец | 2,35 | 0,80 | 6,80 |
| List<T> | Добавление в начало | 904,22 | 826,19 | 992,44 |
| List<T> | Добавление в середину | 418,11 | 381,19 | 440,71 |
| List<T> | Удаление из начала | 673,96 | 648,83 | 705,21 |
| List<T> | Удаление из конца | 0,80 | 0,77 | 0,83 |
| List<T> | Удаление из середины | 355,68 | 330,60 | 405,19 |
| List<T> | Поиск элемента | 0,16 | 0,14 | 0,19 |
| List<T> | Получение по индексу | 0,11 | 0,09 | 0,12 |
| LinkedList<T> | Добавление в конец | 4,94 | 4,20 | 5,71 |
| LinkedList<T> | Добавление в начало | 4,57 | 3,83 | 5,92 |
| LinkedList<T> | Добавление в середину | 4,84 | 4,31 | 6,60 |
| LinkedList<T> | Удаление из начала | 13,09 | 6,82 | 19,56 |
| LinkedList<T> | Удаление из конца | 7,97 | 4,59 | 15,31 |
| LinkedList<T> | Удаление из середины | 23546,27 | 20104,52 | 27934,21 |
| LinkedList<T> | Поиск элемента | 3,45 | 2,87 | 3,95 |
| LinkedList<T> | Получение по индексу | 6,97 | 4,34 | 15,58 |
| Queue<T> | Добавление в конец (Enqueue) | 2,20 | 1,58 | 2,58 |
| Queue<T> | Удаление из начала (Dequeue) | 1,53 | 1,46 | 1,64 |
| Queue<T> | Поиск элемента | 0,11 | 0,10 | 0,13 |
| Stack<T> | Добавление в конец (Push) | 0,69 | 0,49 | 1,06 |
| Stack<T> | Удаление из конца (Pop) | 1,21 | 0,93 | 1,81 |
| Stack<T> | Поиск элемента | 0,14 | 0,10 | 0,22 |
| ImmutableList<T> | Добавление в конец | 95,79 | 84,00 | 106,97 |
| ImmutableList<T> | Добавление в начало | 118,91 | 103,48 | 140,19 |
| ImmutableList<T> | Добавление в середину | 242,56 | 152,41 | 332,94 |
| ImmutableList<T> | Удаление из начала | 86,98 | 73,20 | 107,70 |
| ImmutableList<T> | Удаление из конца | 73,56 | 64,19 | 87,00 |
| ImmutableList<T> | Удаление из середины | 73,83 | 66,84 | 81,44 |
| ImmutableList<T> | Поиск элемента | 3,24 | 2,31 | 3,75 |
| ImmutableList<T> | Получение по индексу | 5,38 | 2,33 | 11,94 |

### Анализ результатов

На основе теоретической сложности алгоритмов и структуры данных можно ожидать следующие результаты:

**Добавление в конец:**
- List<T>, LinkedList<T>, Queue<T>, Stack<T> показывают O(1) амортизированное время
- ImmutableList<T> имеет O(log n) сложность

**Добавление в начало:**
- List<T> имеет O(n) сложность из-за необходимости сдвига элементов
- LinkedList<T> имеет O(1) сложность
- ImmutableList<T> имеет O(log n) сложность

**Добавление в середину:**
- List<T> имеет O(n) сложность
- LinkedList<T> имеет O(1) при наличии ссылки на узел, иначе O(n) для поиска позиции
- ImmutableList<T> имеет O(log n) сложность

**Удаление:**
- Аналогичные закономерности, что и при добавлении
- List<T> быстрее удаляет из конца (O(1)), медленнее из начала/середины (O(n))
- LinkedList<T> быстро удаляет из начала/конца (O(1))

**Поиск:**
- Все коллекции имеют O(n) сложность для линейного поиска

**Доступ по индексу:**
- List<T> имеет O(1) сложность
- LinkedList<T> имеет O(n) сложность
- ImmutableList<T> имеет O(log n) сложность

## 3. Анализ преимуществ и недостатков коллекций

### 3.1 List<T>

**Преимущества:**
- Быстрое добавление в конец: O(1) амортизированное время
- Мгновенный доступ по индексу: O(1)
- Эффективное использование памяти (хранение в массиве)
- Хорошая производительность для последовательного доступа
- Универсальность для большинства задач

**Недостатки:**
- Медленное добавление/удаление в начало/середину: O(n) из-за необходимости сдвига элементов
- Медленный поиск: O(n) линейный поиск
- Перераспределение памяти при росте коллекции (копирование массива)

### 3.2 LinkedList<T>

**Преимущества:**
- Быстрое добавление/удаление в начало и конец: O(1)
- Быстрая вставка в середину при наличии ссылки на узел: O(1)
- Не требует перераспределения памяти
- Эффективен для частых вставок/удалений

**Недостатки:**
- Медленный доступ по индексу: O(n) - требуется обход списка
- Медленный поиск: O(n)
- Больший расход памяти (хранение ссылок на предыдущий/следующий узел для каждого элемента)
- Плохая локальность данных (узлы могут быть разбросаны в памяти)

### 3.3 Queue<T>

**Преимущества:**
- Быстрое добавление (Enqueue): O(1)
- Быстрое удаление (Dequeue): O(1)
- Реализует FIFO (First In, First Out) семантику
- Оптимизирован для работы с очередями

**Недостатки:**
- Ограниченный набор операций (только добавление в конец, удаление из начала)
- Медленный поиск: O(n)
- Нет доступа по индексу
- Нельзя вставлять/удалять в середину

### 3.4 Stack<T>

**Преимущества:**
- Быстрое добавление (Push): O(1)
- Быстрое удаление (Pop): O(1)
- Реализует LIFO (Last In, First Out) семантику
- Оптимизирован для работы со стеками

**Недостатки:**
- Ограниченный набор операций (только добавление/удаление с конца)
- Медленный поиск: O(n)
- Нет доступа по индексу
- Нельзя вставлять/удалять в середину или начало

### 3.5 ImmutableList<T>

**Преимущества:**
- Неизменяемость: безопасность в многопоточных сценариях
- Возможность совместного использования данных (структурное разделение)
- Доступ по индексу: O(log n)
- Безопасность от случайных изменений

**Недостатки:**
- Медленнее мутабельных коллекций для большинства операций
- Создание новой версии при каждой операции (расход памяти)
- Сложность O(log n) для большинства операций
- Не подходит для высокопроизводительных сценариев с большими объемами данных

## 4. Рекомендации о применении коллекций

### 4.1 Выбор коллекции по сценарию использования

**List<T>** рекомендуется использовать когда:
- Требуется частый доступ по индексу
- Большинство операций - добавление в конец
- Нужна универсальная коллекция для различных задач
- Важна производительность последовательного доступа

**LinkedList<T>** рекомендуется использовать когда:
- Частые вставки/удаления в начало или конец коллекции
- Не требуется доступ по индексу
- Важна производительность операций вставки/удаления в произвольных позициях (при наличии ссылки на узел)

**Queue<T>** рекомендуется использовать когда:
- Реализация очереди (FIFO)
- Задачи планирования, обработки запросов
- Нужна специализированная структура для очередей

**Stack<T>** рекомендуется использовать когда:
- Реализация стека (LIFO)
- Рекурсивные алгоритмы
- Механизм отмены операций (undo/redo)
- Нужна специализированная структура для стеков

**ImmutableList<T>** рекомендуется использовать когда:
- Многопоточные приложения (безопасность потоков)
- Требуется гарантия неизменяемости данных
- Функциональное программирование
- Нужна безопасность от случайных изменений

### 4.2 Общие рекомендации

1. **Для большинства случаев** используйте List<T> - это наиболее универсальная и производительная коллекция с оптимальным балансом между различными операциями.

2. **Для очередей и стеков** используйте специализированные Queue<T> и Stack<T> - они оптимизированы для своих задач и показывают отличную производительность.

3. **Для частых операций в начале/конце** используйте LinkedList<T>, но учитывайте накладные расходы на память и отсутствие доступа по индексу.

4. **Для многопоточности** используйте ImmutableList<T> или потокобезопасные обертки (ConcurrentQueue, ConcurrentStack, ConcurrentBag).

5. **Избегайте** частых операций вставки/удаления в середину List<T> - это очень медленно (O(n)). В таких случаях лучше использовать LinkedList<T>.

6. **При выборе коллекции** основывайтесь на конкретных требованиях к операциям и сценарию использования, а не на общих предположениях о производительности.

### 4.3 Выводы

На основе анализа структуры данных и производительности операций можно сделать следующие выводы:

1. List<T> является наиболее универсальной коллекцией с хорошей производительностью для большинства операций, особенно для доступа по индексу и добавления в конец.

2. LinkedList<T> превосходит List<T> при частых операциях вставки/удаления в начале или конце, но проигрывает при доступе по индексу.

3. Queue<T> и Stack<T> специализированы для своих задач и показывают отличную производительность для операций добавления/удаления в соответствующих позициях.

4. ImmutableList<T> жертвует производительностью ради безопасности и неизменяемости, что критически важно в многопоточных приложениях.

5. Выбор коллекции должен основываться на конкретных требованиях к операциям и сценарию использования, учитывая как производительность, так и структуру данных.

